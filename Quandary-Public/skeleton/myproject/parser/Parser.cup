package parser;

import java.util.*;
import java.io.*;
import java_cup.runtime.Symbol;
import java_cup.runtime.ComplexSymbolFactory.ComplexSymbol;
import java_cup.runtime.ComplexSymbolFactory;

import ast.*;
import interpreter.Interpreter;

parser code {: 
  Lexer lexer;

  public Parser(Lexer lex, ComplexSymbolFactory sf) {
    super(lex, sf);
    lexer = lex;
  }

  public void report_fatal_error(String message, Object info) {
    Interpreter.fatalError(message + " (" + info + ")", Interpreter.EXIT_PARSING_ERROR);
  }

  ast.Location loc(int line, int column) {
    return new ast.Location(line, column);
  }

:};

terminal PLUS, MINUS, TIMES, COMMA;
terminal LPAREN, RPAREN;
terminal LCURLY, RCURLY;
terminal RETURN, PRINT, SEMI;
terminal INT;
terminal EQUAL;
terminal IF, ELSE;
terminal LESSEQUAL, LARGEEQUAL, NOTEQUAL, ISEQUAL, LESS, LARGER, AND, OR, NOT;

terminal Long    INTCONST;
terminal String   IDENT;

non terminal Program         program;
non terminal Expr            expr;
non terminal BinaryExpr      binaryExpr;
non terminal Cond            cond;
non terminal Stmt            stmt;
non terminal List<Stmt>      stmtList;
non terminal FunctionDefinition     funcDef;
non terminal List<FunctionDefinition> funcDefList;
non terminal List<String>           formalDeclList;
non terminal List<String>           neFormalDeclList;
non terminal List<Expr>             exprList;
non terminal List<Expr>             neExprList;

precedence left PRINT;
precedence left IF;
precedence left ELSE;
precedence left AND, OR;
precedence left NOT;
precedence left LESSEQUAL, LARGEEQUAL, ISEQUAL, NOTEQUAL, LESS, LARGER;
precedence left PLUS, MINUS;
precedence left TIMES;

start with program;

program ::= funcDefList:fdl
            {: RESULT = new Program(fdl, loc(fdlleft, fdlright)); :}
         ;

funcDefList ::= funcDef:fd funcDefList:fdl 
               {: fdl.add(0, fd); RESULT = fdl; :}
            |  {: RESULT = new ArrayList<FunctionDefinition>(); :}    
            ;
            
funcDef ::= INT IDENT:funcName LPAREN formalDeclList:fdl RPAREN LCURLY stmtList:sl RCURLY
            {: RESULT = new FunctionDefinition(funcName, fdl, sl, loc(slleft, slright)); :}
         ;

formalDeclList ::= neFormalDeclList:nfdl
                     {: RESULT = nfdl; :}
                  |  {: RESULT = new ArrayList<String>(); :}
                  ;

neFormalDeclList ::= INT IDENT:i COMMA neFormalDeclList:nfdl
                     {: nfdl.add(0, i); RESULT = nfdl; :}
                  |  INT IDENT:i
                     {: List<String> nfd = new ArrayList<String>(); nfd.add(0, i); RESULT = nfd; :}
                  ;

stmtList ::= stmt:st stmtList:sl
            {: sl.add(0, st); RESULT = sl; :}
         |  {: RESULT = new ArrayList<Stmt>(); :}
         ;

stmt ::= INT IDENT:i EQUAL expr:e SEMI
         {: RESULT = new DeclStmt(i, e, loc(ileft, iright)); :}
      |  IF cond:c stmt:s
         {: RESULT = new IfStmt(c, s, loc(cleft, cright)); :}
      |  IF cond:c stmt:s1 ELSE stmt:s2
         {: RESULT = new IfElseStmt(c, s1, s2, loc(cleft, cright)); :}
      |  RETURN expr:e SEMI
         {: RESULT = new ReturnStmt(e, loc(eleft, eright)); :}
      |  PRINT expr:e SEMI
         {: RESULT = new PrintStmt(e, loc(eleft, eright)); :}
      | LCURLY stmtList:sl RCURLY
         {: RESULT = new StmtList(sl, loc(slleft, slright)); :}
      ;

exprList ::= neExprList:nel
                  {: RESULT = nel; :}
               |  {: RESULT = new ArrayList<Expr>(); :}
               ;

neExprList ::= expr:e COMMA neExprList:nel
                  {: nel.add(0, e); RESULT = nel; :}
               | expr:e
                  {: List<Expr> nel = new ArrayList<Expr>(); nel.add(0, e); RESULT = nel; :}
               ;

expr ::= INTCONST:c
         {: RESULT = new ConstExpr(c, loc(cleft, cright)); :}
      |  IDENT:c
         {: RESULT = new IdentExpr(c, loc(cleft, cright)); :}
      |  IDENT:i LPAREN exprList:el RPAREN
         {: RESULT = new FunctionCallExpr(i, el, loc(ileft, iright)); :}
      |  binaryExpr:e
         {: RESULT = e; :}
      |  LPAREN expr:e RPAREN
         {: RESULT = e; :}
      |  MINUS expr:e
         {: RESULT = new UnaryExpr(UnaryExpr.NEGATIVE, e, loc(eleft, eright)); :}
      ;

cond ::= expr:c1 LESSEQUAL expr:c2
         {: RESULT = new CompCond(c1, CompCond.LESSEQUAL, c2, loc(c1left, c1right)); :}
      |  expr:c1 LARGEEQUAL expr:c2
         {: RESULT = new CompCond(c1, CompCond.LARGEEQUAL, c2, loc(c1left, c1right)); :}
      |  expr:c1 ISEQUAL expr:c2
         {: RESULT = new CompCond(c1, CompCond.ISEQUAL, c2, loc(c1left, c1right)); :}
      |  expr:c1 NOTEQUAL expr:c2
         {: RESULT = new CompCond(c1, CompCond.NOTEQUAL, c2, loc(c1left, c1right)); :}
      |  expr:c1 LESS expr:c2
         {: RESULT = new CompCond(c1, CompCond.LESS, c2, loc(c1left, c1right)); :}
      |  expr:c1 LARGER expr:c2
         {: RESULT = new CompCond(c1, CompCond.LARGER, c2, loc(c1left, c1right)); :}
      |  cond:c1 AND cond:c2
         {: RESULT = new LogicalCond(c1, LogicalCond.AND, c2, loc(c1left, c1right)); :}
      |  cond:c1 OR cond:c2
         {: RESULT = new LogicalCond(c1, LogicalCond.OR, c2, loc(c1left, c1right)); :}
      |  NOT cond:c
         {: RESULT = new UnaryCond(UnaryCond.NOT, c, loc(cleft, cright)); :}
      |  LPAREN cond:c RPAREN
         {: RESULT = c; :}
      ;

binaryExpr ::= expr:e1 PLUS expr:e2
               {: RESULT = new BinaryExpr(e1, BinaryExpr.PLUS, e2, loc(e1left, e1right)); :}
            |  expr:e1 MINUS expr:e2
               {: RESULT = new BinaryExpr(e1, BinaryExpr.MINUS, e2, loc(e1left, e1right)); :}
            |  expr:e1 TIMES expr:e2
               {: RESULT = new BinaryExpr(e1, BinaryExpr.TIMES, e2, loc(e1left, e1right)); :}
            ;
